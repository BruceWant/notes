ssh
# temporarily stat up the ssh service

systemctl start ssh.socket
systemctl stop ssh.socket

/etc/init.d/ssh restart

# run after system boot
update-rc.d ssh enable


#permanently enable the ssh service when the system is booted

systemctl enable ssh.service
systemctl start ssh.service	# use ssh immediately without
				# having to reboot
systemctl status ssh.service	# check the status of the service
systemctl stop ssh.service	# stop the ssh service
systemctl disable ssh.service	# disable the ssh service so it no longer
				# starts at boot
/etc/init.d/ssh restart		# restart ssh
sudo service ssh restart	# restart ssh


git
# add a remote url to a git repository

git remote add origin git@github.com:BruceWant/something
# something equal delete old url and add new url
git remote set-url origin git@github.com:BruceWant/something_else
git push -u origin master
# show origin remote url
git config --get remote.origin.url
git remote show origin



vim
# save a read noly file

:w !sudo tee %			# :w - write a file
				# !sudo - call shell with sudo command
				# tee - the output of write (vim :w)
				# command redirected using tee
				# % - the % is nothing but current file
				# name.

Ctrl + V (uppercase)
select lines, go to first column
Shift + I (uppercase)
press whatever punctuaction that comment a line
press Esc , or press x for uncomment


gdb
# step into
si

# print the value of register
p /d $eax	# decimal
p /x $eax	# hex
p /t $eax	# binary
p /f $eax	# floating point
p /i $eax	# instruction
p /c $eax	# character

#print the value at address
x/s 0x1234	# x/s hex_address   print value as string
x/d 0x1234	# x/d hex_address   print value as decimal
x/i 0x1234	# x/i hex_address   print value as instruction
x/8xw 0x1234	# x/8xw hex_address print 8 four-byte words in hex format
help x
i r eax

#print the address of a variable
info address variable	# e.g.	info address var_name

# print the value of all registers
info registers
#shortcut
i r

# set breakpoint at address 0x7c00
break *0x7c00
# continue until the next breakpoint
c
# through instructions N at a time
si N
# examine instructions in memory
x/i
# N is the number of consecutive instructions
# and ADDR is the memory address to start
x/Ni ADDR


tcpdump
# capture the specified port Protocol Tcp
tcpdump -ni ens33 tcp port 5788




#ubuntu 18.04 install input
sudo apt-get install ibus-pinyin
# or
sudo apt-get install fcitx-pinyin

2. setting->region&language->manage installed language
3. input sources


# ubuntu install kernel source code 
apt-cache search linux-source
apt-get source linux-source-$(result from "apt-cache search linux-source")


# 6.828
cd ~/6_828/6.828mit/lab
# login to JOS
make qemu
# quit from JOS
ctrl+a x

# debug JOS
make qemu-gdb
make gdb


# asm
gcc -S hello.c
gcc -S -o asm.s hello.c
gcc -g -o hello hello.c
objdump -S --disassemble hello > hello.dump

start
break linenumber
layout asm


# objdump
# examine the full list of the names, size,
# and link addresses of all the section
objdump -h objectfile
VMA: link address
LMA: load address
# inspect the program headers
objdump -x objecfile
# see the entry point of the executable
objdump -f objecfile


# get environment variable 
printenv VARIABLE_NAME
env
set		# assigns a environment variable
unset		# delete environment variable
export		# exports the value of the 
		# newly assigned environment variable

# add a directory to the environment variable path
sudo vim ~/.bashrc
export PATH="/home/user_name/bin:$PATH"
# or another way
vim ~/.profile
if [ -d "$HOME/bin" ] ; then
	PATH="$PATH:$HOME/bin"
fi


# compress file and uncompress
tar -xvf filename.tar.gz	# or -zxvf
tar -xvf filename.tar.bz2	# or -jxvf
tar -xvf filename.tar.xz	# or -Jxvf
tar -xvf filename.tar.Z		# or -Zxvf
unrar x	filename.rar		# install unrar-free

z:	gzip			压缩格式
x:	extract			解压
v:	verbose			详细信息
f:	file(file=archieve)	文件



# Ubuntu install cross-platform compiler: mingw-w64
sudo apt install mingw-w64

# use it
x86_64-w64-mingw32-gcc		# 64 bit
i686-w64-mingw32-gcc		# 32 bit



# shared and static library
# 1. shared library
gcc test.c -fPIC -shared -o libtest.so
				# -fPIC represent position 
				# nonrelated code.
readelf -h libtest.so		# Check the header of the
				# the libtest.so.
gcc -o main main.c -L . -ltest	# Linking when load program.
ldd main			# Check shared libarary
				# denpendency.
cp libtest.so /usr/lib		# Copy shared libaray to
				# system library.
export LD_LIBRARY_PATH=./	# Or add envaironment variable.
gcc main.c -ldl -L . -o main	# Linking when used module.

# 2. static library
gcc -c test1.c			# produce test1.o
readelf -h test1.o		# check the header of the
				# test1.o
ar -rcs libtest1.a test1.o	# produce static library
				# libtest1.a
ar -t libtest1.a		# check content of the libtest1.a

				# liking libtest1.a into main
				# ./ means libtest1.a on the 
				# current directory.
gcc -o main main.c -L ./ -ltest1
				# test0.c call function that in
				# test1.c.
gcc -o main main.c -L ./ -ltest1 -ltest0


